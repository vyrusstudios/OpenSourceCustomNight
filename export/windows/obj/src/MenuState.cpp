// Generated by Haxe 4.1.5
#include <hxcpp.h>

#ifndef INCLUDED_CoolUtil
#include <CoolUtil.h>
#endif
#ifndef INCLUDED_Icon
#include <Icon.h>
#endif
#ifndef INCLUDED_MenuState
#include <MenuState.h>
#endif
#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1f119275e66a7b90_15_new,"MenuState","new",0xe563b1c4,"MenuState.new","MenuState.hx",15,0xdfbcb22c)
HX_LOCAL_STACK_FRAME(_hx_pos_1f119275e66a7b90_25_create,"MenuState","create",0xe57b7c18,"MenuState.create","MenuState.hx",25,0xdfbcb22c)
HX_LOCAL_STACK_FRAME(_hx_pos_1f119275e66a7b90_48_update,"MenuState","update",0xf0719b25,"MenuState.update","MenuState.hx",48,0xdfbcb22c)
HX_LOCAL_STACK_FRAME(_hx_pos_1f119275e66a7b90_64_createIconGrid,"MenuState","createIconGrid",0x591eab17,"MenuState.createIconGrid","MenuState.hx",64,0xdfbcb22c)
HX_LOCAL_STACK_FRAME(_hx_pos_1f119275e66a7b90_102_checkDesc,"MenuState","checkDesc",0xcc572b9d,"MenuState.checkDesc","MenuState.hx",102,0xdfbcb22c)

void MenuState_obj::__construct( ::Dynamic MaxSize){
            	HX_STACKFRAME(&_hx_pos_1f119275e66a7b90_15_new)
HXLINE(  61)		::String library = null();
HXDLIN(  61)		this->characterDescriptionList = ::CoolUtil_obj::coolTextFile(::Paths_obj::getPath(((HX_("data/",c5,0e,88,d4) + HX_("characterInfo",b7,c8,a7,3e)) + HX_(".txt",02,3f,c0,1e)),HX_("TEXT",ad,94,ba,37),library));
HXLINE(  60)		this->characterList = ::CoolUtil_obj::coolTextFile(HX_("assets/data/characters.txt",65,a7,26,9f));
HXLINE(  59)		this->characters = ::Array_obj< Float >::__new(0);
HXLINE(  58)		this->chrSprites = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  56)		this->curColumn = ((Float)0);
HXLINE(  55)		this->curRow = ((Float)0);
HXLINE(  54)		this->rowsGrid = ((Float)5);
HXLINE(  53)		this->columnsGrid = ((Float)5);
HXLINE(  20)		this->animatronicSelected = false;
HXLINE(  15)		super::__construct(MaxSize);
            	}

Dynamic MenuState_obj::__CreateEmpty() { return new MenuState_obj; }

void *MenuState_obj::_hx_vtable = 0;

Dynamic MenuState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< MenuState_obj > _hx_result = new MenuState_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool MenuState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x32c1072e) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x32c1072e;
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void MenuState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_1f119275e66a7b90_25_create)
HXLINE(  26)		this->super::create();
HXLINE(  27)		this->createIconGrid();
HXLINE(  29)		this->goBTN =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  30)		 ::flixel::FlxSprite _hx_tmp = this->goBTN;
HXDLIN(  30)		::String library = null();
HXDLIN(  30)		_hx_tmp->loadGraphic(::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + HX_("ui/mainMenu/go_deselected",57,69,4a,6b)) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),library),null(),null(),null(),null(),null());
HXLINE(  31)		this->goBTN->setGraphicSize(200,0);
HXLINE(  32)		this->goBTN->set_x(( (Float)(1050) ));
HXLINE(  33)		this->goBTN->set_y(( (Float)(490) ));
HXLINE(  34)		this->add(this->goBTN);
HXLINE(  36)		this->infoBox =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,2000,2000,null());
HXLINE(  37)		 ::flixel::FlxSprite _hx_tmp1 = this->infoBox;
HXDLIN(  37)		::String library1 = null();
HXDLIN(  37)		_hx_tmp1->loadGraphic(::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + HX_("ui/mainMenu/infoBox",c1,65,4c,2e)) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),library1),null(),null(),null(),null(),null());
HXLINE(  38)		this->add(this->infoBox);
HXLINE(  40)		this->info =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(this->infoBox->x + 4),(this->infoBox->y + 2),316,HX_("Animatronic: Info",bb,b5,f0,cd),10,false);
HXLINE(  41)		this->info->set_x((this->infoBox->x + 4));
HXLINE(  42)		this->info->set_y((this->infoBox->y + 2));
HXLINE(  43)		this->info->set_color(-1);
HXLINE(  44)		this->add(this->info);
            	}


void MenuState_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_1f119275e66a7b90_48_update)
HXLINE(  49)		this->super::update(elapsed);
HXLINE(  50)		this->checkDesc();
            	}


void MenuState_obj::createIconGrid(){
            	HX_GC_STACKFRAME(&_hx_pos_1f119275e66a7b90_64_createIconGrid)
HXLINE(  66)		{
HXLINE(  66)			int _g = 0;
HXDLIN(  66)			::Array< ::String > _g1 = this->characterList;
HXDLIN(  66)			while((_g < _g1->length)){
HXLINE(  66)				::String character = _g1->__get(_g);
HXDLIN(  66)				_g = (_g + 1);
HXLINE(  68)				::Array< Float > _hx_tmp = this->characters;
HXDLIN(  68)				_hx_tmp->push(this->characterList->indexOf(character,0));
HXLINE(  69)				::Array< ::Dynamic> _hx_tmp1 = this->chrSprites;
HXDLIN(  69)				_hx_tmp1->push( ::Icon_obj::__alloc( HX_CTX ,character,this->curColumn,this->curRow));
HXLINE(  71)				::haxe::Log_obj::trace((character + HX_(" Loaded!",3c,28,8f,fc)),::hx::SourceInfo(HX_("source/MenuState.hx",20,5f,da,e4),71,HX_("MenuState",d2,bf,b6,c0),HX_("createIconGrid",fb,19,ae,c3)));
            			}
            		}
HXLINE(  75)		{
HXLINE(  75)			int _g2 = 0;
HXDLIN(  75)			int _g3 = this->characters->length;
HXDLIN(  75)			while((_g2 < _g3)){
HXLINE(  75)				_g2 = (_g2 + 1);
HXDLIN(  75)				int i = (_g2 - 1);
HXLINE(  77)				if ((this->curColumn > this->columnsGrid)) {
HXLINE(  79)					this->curColumn = ( (Float)(0) );
HXLINE(  80)					this->curRow++;
            				}
HXLINE(  84)				this->chrSprites->__get(i).StaticCast<  ::Icon >()->set_x((5 + (( (Float)(100) ) * this->curColumn)));
HXLINE(  85)				this->chrSprites->__get(i).StaticCast<  ::Icon >()->set_y((5 + (( (Float)(150) ) * this->curRow)));
HXLINE(  88)				this->iconSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(5 + (( (Float)(100) ) * this->curColumn)),(5 + (( (Float)(150) ) * this->curRow)),null());
HXLINE(  89)				this->iconSprite->loadGraphic(HX_("assets/images/IconOverlay.png",67,72,38,bf),null(),null(),null(),null(),null());
HXLINE(  90)				this->iconSprite->setGraphicSize(100,150);
HXLINE(  91)				this->iconSprite->set_antialiasing(true);
HXLINE(  93)				this->add(this->chrSprites->__get(i).StaticCast<  ::Icon >());
HXLINE(  94)				this->add(this->iconSprite);
HXLINE(  95)				::haxe::Log_obj::trace(i,::hx::SourceInfo(HX_("source/MenuState.hx",20,5f,da,e4),95,HX_("MenuState",d2,bf,b6,c0),HX_("createIconGrid",fb,19,ae,c3)));
HXLINE(  97)				this->curColumn++;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(MenuState_obj,createIconGrid,(void))

void MenuState_obj::checkDesc(){
            	HX_STACKFRAME(&_hx_pos_1f119275e66a7b90_102_checkDesc)
HXLINE( 103)		this->info->set_x((this->infoBox->x + 4));
HXLINE( 104)		this->info->set_y((this->infoBox->y + 2));
HXLINE( 106)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE( 108)			int _g = 0;
HXDLIN( 108)			::Array< ::Dynamic> _g1 = this->chrSprites;
HXDLIN( 108)			while((_g < _g1->length)){
HXLINE( 108)				 ::Icon chrSprite = _g1->__get(_g).StaticCast<  ::Icon >();
HXDLIN( 108)				_g = (_g + 1);
HXLINE( 110)				if (::flixel::FlxG_obj::mouse->overlaps(chrSprite,null())) {
HXLINE( 112)					chrSprite->SetDesc();
HXLINE( 113)					this->infoBox->set_x((chrSprite->x + 100));
HXLINE( 114)					this->infoBox->set_y((chrSprite->y + 150));
HXLINE( 115)					this->info->set_text(chrSprite->desc);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(MenuState_obj,checkDesc,(void))


::hx::ObjectPtr< MenuState_obj > MenuState_obj::__new( ::Dynamic MaxSize) {
	::hx::ObjectPtr< MenuState_obj > __this = new MenuState_obj();
	__this->__construct(MaxSize);
	return __this;
}

::hx::ObjectPtr< MenuState_obj > MenuState_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic MaxSize) {
	MenuState_obj *__this = (MenuState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(MenuState_obj), true, "MenuState"));
	*(void **)__this = MenuState_obj::_hx_vtable;
	__this->__construct(MaxSize);
	return __this;
}

MenuState_obj::MenuState_obj()
{
}

void MenuState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(MenuState);
	HX_MARK_MEMBER_NAME(goBTN,"goBTN");
	HX_MARK_MEMBER_NAME(animatronicSelected,"animatronicSelected");
	HX_MARK_MEMBER_NAME(infoBox,"infoBox");
	HX_MARK_MEMBER_NAME(info,"info");
	HX_MARK_MEMBER_NAME(columnsGrid,"columnsGrid");
	HX_MARK_MEMBER_NAME(rowsGrid,"rowsGrid");
	HX_MARK_MEMBER_NAME(curRow,"curRow");
	HX_MARK_MEMBER_NAME(curColumn,"curColumn");
	HX_MARK_MEMBER_NAME(iconSprite,"iconSprite");
	HX_MARK_MEMBER_NAME(chrSprites,"chrSprites");
	HX_MARK_MEMBER_NAME(characters,"characters");
	HX_MARK_MEMBER_NAME(characterList,"characterList");
	HX_MARK_MEMBER_NAME(characterDescriptionList,"characterDescriptionList");
	 ::flixel::FlxState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void MenuState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(goBTN,"goBTN");
	HX_VISIT_MEMBER_NAME(animatronicSelected,"animatronicSelected");
	HX_VISIT_MEMBER_NAME(infoBox,"infoBox");
	HX_VISIT_MEMBER_NAME(info,"info");
	HX_VISIT_MEMBER_NAME(columnsGrid,"columnsGrid");
	HX_VISIT_MEMBER_NAME(rowsGrid,"rowsGrid");
	HX_VISIT_MEMBER_NAME(curRow,"curRow");
	HX_VISIT_MEMBER_NAME(curColumn,"curColumn");
	HX_VISIT_MEMBER_NAME(iconSprite,"iconSprite");
	HX_VISIT_MEMBER_NAME(chrSprites,"chrSprites");
	HX_VISIT_MEMBER_NAME(characters,"characters");
	HX_VISIT_MEMBER_NAME(characterList,"characterList");
	HX_VISIT_MEMBER_NAME(characterDescriptionList,"characterDescriptionList");
	 ::flixel::FlxState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val MenuState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"info") ) { return ::hx::Val( info ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"goBTN") ) { return ::hx::Val( goBTN ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"curRow") ) { return ::hx::Val( curRow ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"infoBox") ) { return ::hx::Val( infoBox ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"rowsGrid") ) { return ::hx::Val( rowsGrid ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curColumn") ) { return ::hx::Val( curColumn ); }
		if (HX_FIELD_EQ(inName,"checkDesc") ) { return ::hx::Val( checkDesc_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"iconSprite") ) { return ::hx::Val( iconSprite ); }
		if (HX_FIELD_EQ(inName,"chrSprites") ) { return ::hx::Val( chrSprites ); }
		if (HX_FIELD_EQ(inName,"characters") ) { return ::hx::Val( characters ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"columnsGrid") ) { return ::hx::Val( columnsGrid ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"characterList") ) { return ::hx::Val( characterList ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"createIconGrid") ) { return ::hx::Val( createIconGrid_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"animatronicSelected") ) { return ::hx::Val( animatronicSelected ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"characterDescriptionList") ) { return ::hx::Val( characterDescriptionList ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val MenuState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"info") ) { info=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"goBTN") ) { goBTN=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"curRow") ) { curRow=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"infoBox") ) { infoBox=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"rowsGrid") ) { rowsGrid=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curColumn") ) { curColumn=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"iconSprite") ) { iconSprite=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"chrSprites") ) { chrSprites=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"characters") ) { characters=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"columnsGrid") ) { columnsGrid=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"characterList") ) { characterList=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"animatronicSelected") ) { animatronicSelected=inValue.Cast< bool >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"characterDescriptionList") ) { characterDescriptionList=inValue.Cast< ::Array< ::String > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void MenuState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("goBTN",14,cd,d6,97));
	outFields->push(HX_("animatronicSelected",e2,71,99,ee));
	outFields->push(HX_("infoBox",3d,b6,ff,0d));
	outFields->push(HX_("info",6e,38,bb,45));
	outFields->push(HX_("columnsGrid",43,e2,72,6e));
	outFields->push(HX_("rowsGrid",7f,f8,16,7b));
	outFields->push(HX_("curRow",7a,84,cf,3e));
	outFields->push(HX_("curColumn",76,68,18,37));
	outFields->push(HX_("iconSprite",5e,98,29,15));
	outFields->push(HX_("chrSprites",21,a6,31,b4));
	outFields->push(HX_("characters",aa,58,ce,55));
	outFields->push(HX_("characterList",a7,ac,9f,40));
	outFields->push(HX_("characterDescriptionList",d1,31,9b,b5));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo MenuState_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(MenuState_obj,goBTN),HX_("goBTN",14,cd,d6,97)},
	{::hx::fsBool,(int)offsetof(MenuState_obj,animatronicSelected),HX_("animatronicSelected",e2,71,99,ee)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(MenuState_obj,infoBox),HX_("infoBox",3d,b6,ff,0d)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(MenuState_obj,info),HX_("info",6e,38,bb,45)},
	{::hx::fsFloat,(int)offsetof(MenuState_obj,columnsGrid),HX_("columnsGrid",43,e2,72,6e)},
	{::hx::fsFloat,(int)offsetof(MenuState_obj,rowsGrid),HX_("rowsGrid",7f,f8,16,7b)},
	{::hx::fsFloat,(int)offsetof(MenuState_obj,curRow),HX_("curRow",7a,84,cf,3e)},
	{::hx::fsFloat,(int)offsetof(MenuState_obj,curColumn),HX_("curColumn",76,68,18,37)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(MenuState_obj,iconSprite),HX_("iconSprite",5e,98,29,15)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(MenuState_obj,chrSprites),HX_("chrSprites",21,a6,31,b4)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(MenuState_obj,characters),HX_("characters",aa,58,ce,55)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(MenuState_obj,characterList),HX_("characterList",a7,ac,9f,40)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(MenuState_obj,characterDescriptionList),HX_("characterDescriptionList",d1,31,9b,b5)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *MenuState_obj_sStaticStorageInfo = 0;
#endif

static ::String MenuState_obj_sMemberFields[] = {
	HX_("goBTN",14,cd,d6,97),
	HX_("animatronicSelected",e2,71,99,ee),
	HX_("infoBox",3d,b6,ff,0d),
	HX_("info",6e,38,bb,45),
	HX_("create",fc,66,0f,7c),
	HX_("update",09,86,05,87),
	HX_("columnsGrid",43,e2,72,6e),
	HX_("rowsGrid",7f,f8,16,7b),
	HX_("curRow",7a,84,cf,3e),
	HX_("curColumn",76,68,18,37),
	HX_("iconSprite",5e,98,29,15),
	HX_("chrSprites",21,a6,31,b4),
	HX_("characters",aa,58,ce,55),
	HX_("characterList",a7,ac,9f,40),
	HX_("characterDescriptionList",d1,31,9b,b5),
	HX_("createIconGrid",fb,19,ae,c3),
	HX_("checkDesc",39,27,46,96),
	::String(null()) };

::hx::Class MenuState_obj::__mClass;

void MenuState_obj::__register()
{
	MenuState_obj _hx_dummy;
	MenuState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("MenuState",d2,bf,b6,c0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(MenuState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< MenuState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = MenuState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = MenuState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

